<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
//	class People{
//		constructor(name,age){
//			this.name = name
//			this.age = age
//		}
//		printInfo(){
//			return "name:"+name+",age:"+age;
//		}
//	}
//	Object.assign( People.prototype,{
//		toString(){},
//		consoleSth(){},
//	} );
//	console.log( typeof People );
//	let p = new People('msl',29);
//	//console.log( p );
//	//类本质就是工厂函数，就是原型内的构造方法
//	//console.log( People === People.prototype.constructor );
//	console.log( People.prototype );
//	//类中定义在原型上的方法不可枚举
//	console.log( Object.keys(People.prototype) );
//	class MyClass {
//	  constructor() {
//	    // ...
//	  }
//	  get prop() {
//	    return 'getter';
//	  }
//	  set prop(value) {
//	    console.log('setter: '+value);
//	  }
//	}
//	let mc = new MyClass();
//	mc.prop = 'test';
//	mc.prop;
//	//console.log( mc.prop );
//class CustomHTMLElement {
//constructor(element) {
//  this.element = element;
//}
////类中的getter/setter存取器是定义在原型对象上的
//get html() {
//  return this.element.innerHTML;
//}
//
//set html(value) {
//  this.element.innerHTML = value;
//}
//}
//let ch = new CustomHTMLElement();
//console.log( ch );
//var descriptor = Object.getOwnPropertyDescriptor(
//CustomHTMLElement.prototype, "html"
//);
//console.log( descriptor );
//let methodName = "getArea";
//const PI = 3.1415926;
//class Circle{
//	constructor( _r ){
//		this.r = _r; 
//	}
//	[methodName](){
//		return PI*this.r*this.r;
//	}
//}
//let c1 = new Circle(2);
//console.log( c1.getArea() );
//console.log( c1[methodName]() );//√同上
//表达式
//静态方法
//	class Cat{
//		constructor( _name ){
//			this.name = _name;
//		}
//		static catCounter(){
//			return 'static method';
//		}
//	}
//	console.log( Cat.catCounter() );
//	console.log( new Cat('titi').catCounter() );
	//静态方法中的this指向
//class Foo {
//static bar() {
//  this.baz();//this指向的是类，而不是实例instance
//}
//static baz() {
//  console.log('hello');
//}
//baz() {
//  console.log('world');
//}
//}
//Foo.bar();
//类的继承
//class Foo {
//static classMethod() {//静态方法可以被派生类继承
//  return 'hello';
//}
//}
//class Bar extends Foo {
//}
//class Bar extends Foo {
//static classMethod() {//子类静态方法可以覆盖父类
//  return 'world';
//}
//}
//class Bar extends Foo {
//static classMethod() {//子类利用Super作用域指针调用父类静态方法
//  return super.classMethod()+",too";
//}
//}
////console.log( Bar );
//console.log( Bar.classMethod() );
//实例属性除了定义在constructor里还可以定义在顶端
//class IncreasingCounter {
//	//实例属性依然建议写在contructor里
//	constructor(){
//		this._count = 0;
//	}
//get count() {
//  return this._count;
//}
//set count( val ) {
//  this._count = val;
//}
//}
//let c = new IncreasingCounter( 0 );
//console.log( c.count );
//c.count = 5;
//console.log( c.count );
//类的静态属性
class Cat{
	constructor(){
		Cat.counter++;
	}
}
Cat.counter = 0;
let cats = [];
for( let i=0;i<5;i++ ){
	cats.push( new Cat() );
}
console.log( cats );
console.log( Cat.counter );
	</script>
</html>

<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
<script>
	//set数据结构里没有重复值
//	const s = new Set();
//	[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
//	console.log( s );
	//接受数组或有iterator接口的数据作为初始化数据
//	const set = new Set();
//	console.log( set );
//	let a = [...set];//转化成数组
//	console.log( set.size );
//	//数组去重
//	let a = [1, 2, 3, 4, 4];
//	let b = [...new Set(a)];
//	console.log( b );
	//字符串去重
//	let s = new Set('aabbcc');
//	let s1 = [...s].join('');
//	console.log( s );
//	console.log( s1 );
	//set方法
//	let s = new Set([1,3,5]);
//	console.log( s.delete(1) );
//	console.log( s.has(3) );
//	s.clear();
//	console.log( s );
//	const items = new Set([1, 2, 3, 4, 5]);
//	const array = Array.from(items);
//	console.log( array );
//	console.log( [...items] );
//	let set = new Set(['red', 'green', 'blue']);
//	console.log( set.keys() );
//	for (let item of set.keys()) {
//	  console.log(item);
//	}
//	for (let item of set.values()) {
//	console.log(item);
//	}
//	for (let item of set.entries()) {
//	  console.log(item);
//	}
//	let set = new Set(['red', 'green', 'blue']);
//	set.forEach( (value,index) => console.log(index+":"+value) );
	//set实现并集、交集、差集
	let a1 = [1,2,3];
	let a2 = [2,3,4];
	//console.log( a1.concat(a2) );
	//Union
	//let a3 = [...new Set(a1.concat(a2))];	
//	let a3 = [...new Set([...a1,...a2])];	
//	console.log( a3 );
//	//Intersect
//	let a4 = a1.filter( x=>a2.includes(x) );
//	console.log( a4 );
//	//Difference
//	let a5 = a3.filter(x => !a4.includes(x));
//	console.log( a5 );
//	const set = new Set([
//	  ['foo', 1],
//	  ['bar', 2]
//	]);
//	console.log( set );
//	const m1 = new Map(set);//用set生成map
//	const m2 = new Map( [['name','msl'],['age',29]] );//用二维数组生成map
//	const m3 = new Map( m2 );//用map来初始化
//	console.log( m1.get('bar') );
//	console.log( m2.get('name') );
//	console.log( m3.get('age') );
//	m2.set('name','hly');
//	console.log( m2.get('name') );
//map本质上是值与内存地址相绑定，与内存地址具体指向哪里、存储什么无关
//	let map = new Map();
//	let a = ['a'];
//	let f = function(){};
//	map.set(a,555);//键是数组
//	map.set('str','hi');//键是字符串
//	map.set(0,'100');//键是数字
//	map.set(f,'this is a func');
//	console.log( map.get(a) );
//	console.log( map.get('str') );
//	console.log( map.get(0) );
//	console.log( map.get(f) );
	//has方法
//	const m = new Map();
//	m.set('edition',6);
//	console.log( m.get('edition') );
//	console.log( m.has('edition') );
	//map与数组之间的转化
//	const map = new Map([
//	  [1, 'one'],
//	  [2, 'two'],
//	  [3, 'three'],
//	]);
	//map的遍历和过滤--借助array的方法来实现
	//traverse
	//转化后是元素是数组的数组而已，没有什么特殊之处，将元素按照数组格式处理即可
//	let map1 = new Map( [...map].map( ([key,val]) => [key,val+'test'] ) );
//	console.log( map1 );
//	//filter
//	let map2 = new Map( [...map].filter(([key,val]) => key<3) );
//	console.log( map2 );
	//map自带的forEach,接受第二个参数来做this的绑定
//	const reporter = {
//		report( key,val ){
//			console.log("Key: %s, Value: %s", key, val);
//		}
//	};
//	map.forEach(function(value, key, map) {
//	  this.report(key, value);
//	}, reporter);
//	//箭头函数里的this需要慎用
//	map.forEach( function(value, key, map) {
//	  this.report(key, value);
//	}, reporter );
	//for of的默认值是map键值对里的“值”
//	for( let [key,val] of map ){
//		console.log( key+":"+val );
//	}
	//对象与map的区别：对象的键为字符串，map的键可以为值
	const map = new Map([
	  [1, 'one'],
	  [2, 'two'],
	  [3, 'three'],
	]);
	//map转化为对象
	function objFromMap( map ){
		let o = Object.create( null );
		for([k,v] of map){
			o[k] = v;
		}
		return o;
	}
	//对象转化为map
	function mapFromObj( obj ){
		//方法一，array转map
//		let a = [];
//		for( let prop in obj ){
//			a.push( [prop,obj[prop]] );
//		}
//		return new Map( a );
	//方法二，map的set方法
		let m = new Map();
		for( let prop in obj ){
			m.set( prop,obj[prop] );
		}
		return m;
	}
	let o = objFromMap( map );
	console.log( o );
	let m = mapFromObj( o );
	console.log( m );
	//对象和数组是json和map之间的桥梁
	
</script>
</html>
